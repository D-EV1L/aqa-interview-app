[
    {
        "area": "Основи ООП",
        "title": "Що таке ООП",
        "answer": "<b>ООП</b> (об’єктно-орієнтоване програмування) - це парадигма програмування, яка розглядає програму як множину об’єктів, що взаємодіють між собою. Об’єкти містять дані (атрибути або властивості) та методи (функції або дії), які можуть бути викликані іншими об’єктами. ООП спрощує написання коду, робить його більш модульним, ефективним і масштабованим."
    },
    {
        "area": "Основи ООП",
        "title": "Назвати основні принципи ООП",
        "answer": "Основні принципи ООП - це:<ul><li>Інкапсуляція</li><li>Абстракція</li><li>Наслідування</li><li>Поліморфізм</li></ul>"
    },
    {
        "area": "Основи ООП. Інкапсуляція",
        "title": "Що таке інкапсуляція та як вона представлена в Java",
        "answer": "<b>Інкапсуляція</b> - це приховування деталей реалізації об’єктів від зовнішнього світу. Це означає, що внутрішній стан і поведінка об’єкта захищені від прямого доступу і зміни ззовні. Інші об’єкти можуть спілкуватися з об’єктом тільки через його публічні методи.<p>Інкапсуляція в Java виражена за допомогою модифікаторів доступу та геттерів і сеттерів.</p>"
    },
    {
        "area": "Java Core. Модифікатори доступу",
        "title": "Що таке модифікатори доступу та які є в Java",
        "answer": "<b>Модифікатори доступу</b> - це спеціальні слова, які вказують, хто може мати доступ до даних або методів об’єкта. В Java є чотири модифікатори доступа: <b>public</b>, <b>private</b>, <b>protected</b> і <b>default</b>.<ul><li><b>public</b> означає, що дані або методи доступні для всіх класів і пакетів.</li><li><b>private</b> означає, що дані або методи доступні тільки для того класу, в якому вони оголошені.</li><li><b>protected</b> означає, що дані або методи доступні для того класу, в якому вони оголошені, а також для його нащадків і класів з того ж пакету.</li><li><b>default</b> означає, що дані або методи доступні для класів з того ж пакету, але не для нащадків з інших пакетів.</li></ul><p>Модифікатори доступу дозволяють приховати деталі реалізації об’єкта від зовнішнього світу і контролювати, як інші об’єкти можуть взаємодіяти з ним.</p>"
    },
    {
        "area": "Java Core. Геттери та сеттери",
        "title": "Що таке геттери та сеттери",
        "answer": "<b>Геттери і сеттери</b> - це спеціальні методи, які дозволяють отримувати і змінювати значення приватних даних об’єкта. Геттер - це метод, який повертає значення приватної змінної. Сеттер - це метод, який приймає значення і присвоює його приватній змінній.<p>Геттери і сеттери дозволяють забезпечити безпеку даних об’єкта, перевіряючи їх коректність і логіку перед присвоєнням або поверненням.</p>"
    },
    {
        "area": "Основи ООП. Поліморфізм",
        "title": "Що таке поліморфізм та як він представлений в Java",
        "answer": "<b>Поліморфізм</b> - це здатність об’єктів різних класів виконувати один і той же метод по-різному. Це означає, що одне і те ж повідомлення може спричинити різну реакцію залежно від типу об’єкта, який його отримав.<p>Поліморфізм в Java може бути двох видів: <b>статичний</b> і <b>динамічний</b>.</p><ul><li><b>Статичний поліморфізм</b> - це поліморфізм, який визначається на етапі компіляції. Він досягається за допомогою <b>перегрузки методів (Overload)</b>.</li><li><b>Динамічний поліморфізм</b> - це поліморфізм, який визначається на етапі виконання. Він досягається за допомогою <b>перевизначення методів (Override)</b>.</li></ul>"
    },
    {
        "area": "Java Core. Override та Overload",
        "title": "Що таке Override та Overload. В чому різниця",
        "answer": "<ul><li><b>Override</b> - це перевизначення методу суперкласу в підкласі з тим же ім’ям і параметрами. Це дозволяє змінити поведінку методу в залежності вiд типу об’єкта, який його викликає.</li><li><b>Overload</b> - це перегрузка методу в одному класі з однаковим ім’ям, але різними параметрами. Це дозволяє створити кілька версій методу для різних ситуацій.</li></ul>"
    },
    {
        "area": "Java Core. Override",
        "title": "Чи будь-які методи можна перевизначити (Override)",
        "answer": "Методи, які неможливо перевизначити в Java, - це:<ul><li><b>Статичні методи</b> - методи з ключовим словом <b>static</b>. Статичні методи не можуть бути перевизначені в підкласах, тому що вони не беруть участі в поліморфізмі. Якщо підклас має статичний метод з таким же ім’ям і параметрами, як у суперкласу, то це називається <b>приховуванням методу</b>, а не перевизначенням.</li><li><b>Фінальні методи</b> - це методи, які мають модифікатор доступу <b>final</b>. Це означає, що вони не можуть бути змінені або перевизначені в підкласах. Фінальні методи використовуються для забезпечення безпеки, стабільності і ефективності коду.</li><li><b>Приватні методи</b> - це методи, які мають модифікатор доступу private. Приватні методи не можуть бути перевизначені в підкласах, тому що вони не видимі для них. Приватні методи використовуються для реалізації деталей роботи класу, які не повинні бути доступними ззовні.</li></ul>"
    },
    {
        "area": "Java Core. Overload",
        "title": "Чи можна перевантажувати статичні методи (Overload)",
        "answer": "Так, можна перевантажувати статичні методи в Java. Це означає, що можна створити кілька статичних методів з одним і тим же іменем, але з різними параметрами."
    },
    {
        "area": "Java Core. Overload",
        "title": "ЗАВДАННЯ. Чи можна вважати усі методи перевантаженими",
        "answer": "Ні, перевантаженими є усі окрім другого. При перевантаженні методи повинні мати одинакову назву та різні набори параметрів. Другий метод має такий же набір параметрів як і перший, що викличе помилку компіляції. При цьому тип значення, що повертається - не важливий. Це означає що третій метод теж є перевантаженням першого, хоч і повертає ціле число замість рядка.",
        "code": "public String test() {\n    return \"\";\n}\n\npublic int test() {\n    return 0;\n}\n\npublic int test(int i) {\n    return i;\n}\n\npublic String test(String var) {\n    return var;\n}\n\npublic String test(String var1, String var2) {\n    return var1 + var2;\n}"
    },
    {
        "area": "Java Core. Override",
        "title": "Чи можна змінювати модифікатор доступу при перевизначенні метода",
        "answer": "Так, але перевизначаючий метод не може бути менш доступним, ніж перевизначений. Є наступні правила:<ul><li>Якщо перевизначений метод суперкласу має модифікатор доступу <b>public</b>, то перевизначаючий метод підкласу також повинен мати модифікатор доступу <b>public</b>.</li><li>Якщо перевизначений метод суперкласу має модифікатор доступу <b>protected</b>, то перевизначаючий метод підкласу може мати модифікатор доступу <b>protected</b> або <b>public</b>.</li><li>Якщо перевизначений метод суперкласу має модифікатор доступу за замовчуванням (без модифікатора), то перевизначаючий метод підкласу може мати модифікатор доступу за замовчуванням, <b>protected</b> або <b>public</b>.</li><li>Якщо перевизначений метод суперкласу має модифікатор доступу private, то він не є видимим для підкласу і не може бути перевизначеним.</li></ul>"
    },
    {
        "area": "Java Core. Ключове слово Static",
        "title": "Ключове слово Static. Де та для чого його використовують",
        "answer": "Ключове слово <b>static</b> в Java є модифікатором, який може застосовуватися до змінних, методів, класів і блоків. Ключове слово <b>static</b> має такі особливості:<ul><li><b>Статичні змінні</b> - це змінні, які належать до класу, а не до об’єкта. Вони існують незалежно від створення екземплярів класу і мають одну копію для всього класу. Статичні змінні можна використовувати для збереження спільних даних між усіма об’єктами класу. Статичні змінні можна доступитися безпосередньо за допомогою імені класу.</li><li><b>Статичні методи</b> - це методи, які належать до класу, а не до об’єкта. Вони також існують незалежно від створення екземплярів класу і можуть викликатися безпосередньо за допомогою імені класу. Статичні методи не можуть доступитися до нестатичних змінних або методів, оскільки вони не мають посилання на конкретний об’єкт.</li><li><b>Статичні класи</b> - це вкладені класи, які належать до зовнішнього класу. Вони також існують незалежно від створення екземплярів зовнішнього класу і можуть доступитися тільки до статичних членів зовнішнього класу. Статичним класам не потребується посилання на екземпляр зовнішнього класу для їх створення.</li><li><b>Статичні блоки</b> - це блоки коду, яким передують ключове слово static. Вони виконуються тоді, коли клас завантажується в пам’ять, ще до створення будь-яких об’єктів. Статичним блокам можна використовувати для ініцалiзацiї статичних змiнних або для виконання будь-яких дiй, якi потрiбно зробити один раз.</li></ul>"
    },
    {
        "area": "Java Core. Ключове слово Static",
        "title": "ЗАВДАННЯ. Що буде виведено у консоль",
        "answer": "У консоль буде двічі виведено <b>GlobalLogic EU</b>. Оскільки змінна <b>company</b> є змінною класу, а не об'єктів <b>user1</b> та <b>user2</b>.",
        "code": "public class User {\n    public static String company;\n}\n\nclass Test {\n    public static void main(String[] args) {\n        User user1 = new User();\n        User user2 = new User();\n\n        user1.company = \"GlobalLogic UA\";\n        user2.company = \"GlobalLogic EU\";\n\n        System.out.println(user1.company);\n        System.out.println(user2.company);\n    }\n}"
    },
    {
        "area": "Основи ООП. Абстракція",
        "title": "Що таке абстракція та як вона представлена в Java",
        "answer": "<b>Абстракція</b> - це процес приховування деталей реалізації від користувача та надання лише необхідної функціональності. Абстракція дозволяє зосередитися на тому, що робить об’єкт, а не на тому, як він це робить. В Java абстракція реалізована за допомогою абстрактних класів та інтерфейсів."
    },
    {
        "area": "Java Core. Абстрактні класи",
        "title": "Що таке абстрактний клас і які його особливості",
        "answer": "<b>Абстрактний клас</b> - це клас, який оголошений із ключовим словом <b>abstract</b>. Абстрактні класи не можна інстанціювати, але вони можуть бути успадковані. Абстракний клас може мати або не мати абстрактні методи. <b>Абстрактний метод</b> - це метод, який оголошений без реалізації (без фігурних дужок і з крапкою з комою в кінці). Якщо клас містить абстрактні методи, то сам клас також повинен бути оголошений як <b>abstract</b>. Коли абстрактний клас успадковується, підклас зазвичай надає реалізації для всіх абстрактних методів свого батьківського класу. Однак, якщо він цього не робить, то підклас також повинен бути оголошений як <b>abstract</b>."
    },
    {
        "area": "Java Core. Інтерфейси",
        "title": "Що таке інтерфейс",
        "answer": "<b>Інтерфейс</b> - це тип, який оголошує набір абстрактних методів, яким повинні слідувати всі класи, що його реалізують. Інтерфейси дозволяють досягти багаторазового використання коду та поліморфного поведінки об’єктів. Всі методи в інтерфейсах є неявно абстрактними, тому модифікатор <b>abstract</b> не використовується з ними."
    },
    {
        "area": "Java Core. Інтерфейси",
        "title": "В чому різниця між абстрактним класом та інтерфейсом",
        "answer": "Деякі відмінності:<ul><li>Абстрактний клас може мати конструктор, а інтерфейс - ні.</li><li>Абстрактний клас повинен мати підкласи, які його розширюють, а інтерфейс повинен мати класи, які його реалізують.</li><li>Абстрактний клас може мати модифікатори доступу public, protected та private для своїх методів, а інтерфейс - лише private та public (за замовчуванням усі методи в інтерфейсах неявно оголошені як public).</li><li>Абстрактний клас може наслідуватися лише від одного класу (або не наслідуватися взагалі), а інтерфейс може наслідуватися від багатьох інтерфейсів.</li></ul>"
    },
    {
        "area": "Java Core. Інтерфейси",
        "title": "Чи можна додати реалізацію методу в інтерфейс",
        "answer": "Зазвичай, методи в інтерфейсах не мають реалізації, а тільки оголошення. Однак, починаючи з Java 8, можна додати реалізацію методу в інтерфейс за допомогою модифікатора <b>default</b> або <b>static</b>. Такі методи називаються методами за замовчуванням (default methods) або статичними методами (static methods). Методи за замовчуванням дозволяють додавати нову функціональність в існуючі інтерфейси без порушення сумісності з класами, які їх реалізують. Статичні методи дозволяють створювати допоміжні методи в інтерфейсах, які не залежать від конкретного екземпляру."
    },
    {
        "area": "Java Core. Інтерфейси",
        "title": "Чи можна додати поля в інтерфейс",
        "answer": "Так, але вони неявно будуть оголошені як <b>static</b> та <b>final</b>, а тому потрібно одразу їх ініціалізувати."
    },
    {
        "area": "Java Core. Інтерфейси",
        "title": "Що таке функціональний інтерфейс",
        "answer": "<b>Функціональний інтерфейс</b> - це той інтерфейс, який визначає тільки один абстрактний метод. Такий інтерфейс може бути використаний для створення лямбда-виразів, які реалізують цей метод. Функціональний інтерфейс може мати також методи за замовчуванням, статичні методи та приватні методи, але вони не впливають на його функціональність. Функціональний інтерфейс можна позначити анотацією <b>@FunctionalInterface</b>, яка перевіряє, чи відповідає інтерфейс умовам функціональності."
    },
    {
        "area": "Java Core. Інтерфейси",
        "title": "Чи можна створити обєкт абстрактного класу або інтерфейсу",
        "answer": "Ні, не можна створити об’єкт абстрактного класу або інтерфейсу. Абстрактний клас або інтерфейс є неповною реалізацією, яка містить один або декілька абстрактних методів, тобто методів без тіла. Такий клас або інтерфейс призначений для того, щоб бути наслідуваним іншими класами, які повинні перевизначити всі абстрактні методи."
    },
    {
        "area": "Основи ООП. Наслідування",
        "title": "Що таке наслідування та як воно представлене в Java",
        "answer": "<b>Наслідування</b> - це механізм, який дозволяє створювати нові класи на основі існуючих, переймаючи їх атрибути і методи. Це сприяє повторному використанню коду, униканню дублювання і полегшенню розширення функціональності.<p>В Java наслідування представлене за допомогою ключового слова <b>extends</b>, яке вказує, що клас наслідується від іншого класу."
    },
    {
        "area": "Java Core. Наслідування",
        "title": "Чи може клас наслідувати декілька класів",
        "answer": "Ні, клас не може наслідувати декілька класів в Java. Java не підтримує множинне наслідування, тобто ситуацію, коли клас наслідується від двох або більше класів. Це зроблено для уникнення проблеми ромбовидної спадковості, коли клас наслідується від двох класів, які самі наслідуються від одного базового класу."
    },
    {
        "area": "Java Core. Наслідування",
        "title": "Чи будь-який клас можна наслідувати",
        "answer": "Ні, не будь-який клас можна наслідувати. Класи, які оголошені як <b>final</b>, тобто остаточні, не можуть бути наслідуваними іншими класами, оскільки вони мають закінчену реалізацію, яку не можна змінювати. Наприклад, клас <b>String</b> є <b>final</b>, тому не можна створити клас, який наслідується від нього.<p>Однак, можна наслідувати будь-який не <b>final</b> клас, якщо він не має приватного конструктора. Приватний конструктор означає, що клас може бути інстанційований тільки всередині себе, а не ззовні. Це також перешкоджає наслідуванню цього класу, оскільки при наслідуванні потрібно викликати конструктор базового класу."
    },
    {
        "area": "Java Core. Клас Object",
        "title": "Для чого в Java клас Object та які його основні методи",
        "answer": "Клас <b>Object</b> - це спеціальний клас в Java, від якого наслідуються всі інші класи, навіть якщо це не вказано явно. Клас Object має ряд методів, які доступні для всіх об’єктів в Java. Ось деякі з них:<ul><li><b>protected Object clone()</b> - створює новий об’єкт, який не відрізняється від клонованого. Цей метод використовується для отримання точної копії об’єкта, але його не рекомендується застосовувати, оскільки він може призвести до проблем з безпекою та низькою продуктивністю. Замість нього краще використовувати конструктор копіювання або метод копіювання.</li><li><b>public boolean equals(Object obj)</b> - визначає, чи рівний один об’єкт іншому. Цей метод порівнює два об’єкти за їхньою суттю, а не за їхньою адресою в пам’яті. За замовчуванням, цей метод перевіряє, чи посилаються два об’єкти на один і той же екземпляр класу. Однак, цей метод можна перевизначити в своїх класах, щоб порівнювати об’єкти за їхніми полями або логікою.</li><li><b>public int hashCode()</b> - повертає хеш-код, пов’язаний з викликаючим об’єктом. <b>Хеш-код</b> - це числове представлення об’єкта, яке може бути використане для швидкого пошуку або порівняння об’єктів. За замовчуванням, цей метод повертає адресу пам’яті об’єкта у 16-річному форматі. Однак, цей метод також можна перевизначити в своїх класах, щоб генерувати хеш-коди на основі полів або логіки об’єктів.</li><li><b>public String toString()</b> - повертає символьний рядок, що описує об’єкт. Цей метод використовується для представлення об’єкта у зручному для людини форматі. За замовчуванням, цей метод повертає ім’я класу та хеш-код об’єкта у форматі <b>ім’я_класу@хеш-код</b>. Однак, цей метод також можна перевизначити в своїх класах, щоб повертати більш інформативний або красивий рядок, який відображає стан або характеристики об’єкта.</li></ul>"
    },
    {
        "area": "Java Core. Клас Object",
        "title": "Які правила перевизначення методів hashCode та equals",
        "answer": "При перевизначенні методів <b>hashCode</b> та <b>equals</b> слід дотримуватися наступних правил:<ul><li>Якщо два об’єкти рівні за <b>equals()</b>, то їхні хеш-коди також повинні бути рівними. Це означає, що якщо ви перевизначаєте метод <b>equals()</b>, то вам також потрібно перевизначити метод <b>hashCode()</b>, щоб вони були узгоджені між собою.</li><li>Якщо два об’єкти не рівні за <b>equals()</b>, то їхні хеш-коди можуть бути рівними або не рівними. Однак, краще, щоб вони були не рівними, оскільки це зменшує ймовірність колізій, тобто ситуацій, коли різні об’єкти мають однаковий хеш-код. Колізії можуть погіршити продуктивність деяких колекцій, які використовують хеш-коди для пошуку або збереження об’єктів.</li><li>Метод <b>hashCode()</b> повинен завжди повертати одне і те ж значення для одного і того ж об’єкта протягом одного запуску програми. Це означає, що метод <b>hashCode()</b> не повинен залежати від змінних полів об’єкта, якщо вони можуть змінюватися після створення об’єкта. Зазвичай, метод <b>hashCode()</b> базується на незмінних полях або на таких полях, які використовуються в методі <b>equals()</b>.</li></ul>"
    },
    {
        "area": "Java Core. String pool",
        "title": "Що таке String pool",
        "answer": "<b>String pool</b> - це пул рядків, який зберігається в купі пам’яті Java. Це спеціальна область пам’яті, де JVM оптимізує кількість пам’яті, виділеної для рядків, зберігаючи тільки одну копію кожного літерального рядка. Цей процес називається інтернуванням.<p>Коли ми створюємо рядок за допомогою літерала, наприклад:<pre><code class=\"language-java\">String s = \"Hello\";</code></pre>JVM шукає в пулі рядків рядок з таким самим значенням. Якщо знаходить, то повертає посилання на його адресу в пам’яті, не виділяючи додаткової пам’яті. Якщо не знаходить, то додає рядок до пулу (інтернує) і повертає його посилання.<p>Коли ми створюємо рядок за допомогою оператора <b>new</b>, наприклад:<pre><code class=\"language-java\">String s = new String(\"Hello\");</code></pre>JVM створює новий об’єкт і зберігає його в купі пам’яті, виділеної для JVM. Кожен рядок, створений таким чином, вказує на іншу область пам’яті з своєю адресою."
    },
    {
        "area": "Java Core. String pool",
        "title": "ЗАВДАННЯ. Яких значення набудуть усі boolean змінні",
        "answer": "<ul><li><b>b1 = false</b> - логічне дорівнює <b>==</b> порівнює адреси об'єктів, і оскільки <b>str1</b> та <b>str2</b> створені за допомогою оператора <b>new</b>, вони зберігаються в різних комірках пам'яті.</li><li><b>b2 = false</b> - <b>str1</b> створений за допомогою оператора <b>new</b>, а отже зберігається у відмінній від <b>str3</b> комірці пам'яті.</li><li><b>b3 = true</b> - оскільки метод <b>equals()</b> порівнює внутрішні значення об'єктів.</li><li><b>b4 = true</b> - оскільки <b>str4</b> посилається на <b>str1</b>, а отже на ту ж комірку пам'яті.</li></ul>",
        "code": "class Test {\n    public static void main(String[] args) {\n        String str1 = new String(\"Hello\");\n        String str2 = new String(\"Hello\");\n        String str3 = \"Hello\";\n        String str4 = str1;\n\n        boolean b1 = str1 == str2;\n        boolean b2 = str1 == str3;\n        boolean b3 = str2.equals(str3);\n        boolean b4 = str1 == str4;\n    }\n}"
    },
    {
        "area": "Java. Колекції",
        "title": "Що таке колекції та які колекції є в Java",
        "answer": "Колекції в Java - це фреймворк, який надає архітектуру для зберігання та маніпулювання групами об’єктів. Вони включають інтерфейси, які надають абстрактні типи даних для представлення колекцій, та класи, які надають реалізацію цих інтерфейсів.<p>Основні типи колекцій в Java включають:<ul><li><b>List</b>: Це інтерфейс, який представляє колекцію, що зберігає елементи в визначеному порядку та дозволяє дублювання. Основні класи, що реалізують List, включають <b>ArrayList</b>, <b>LinkedList</b> та <b>Vector</b>.</li><li><b>Set</b>: Це інтерфейс, який представляє колекцію, що не допускає дублювання. <b>HashSet</b>, <b>LinkedHashSet</b> та <b>TreeSet</b> – основні класи, що реалізують Set.</li><li><b>Map</b>: Це інтерфейс, який представляє об’єкт, що зберігає пари ключ/значення. Це не є справжній член колекцій, але він є частиною Java Collections Framework. <b>HashMap</b>, <b>TreeMap</b>, <b>LinkedHashMap</b> та <b>Hashtable</b> – основні класи, що реалізують Map.</li><li><b>Queue</b>: Це інтерфейс, який представляє колекцію, призначену для обробки елементів перед видаленням. <b>PriorityQueue</b>, <b>Deque</b> та <b>ArrayDeque</b> – основні класи, що реалізують Queue.</li></ul><br><p style=\"text-align: center\"><img width=\"100%\" style=\"max-width: 1024px\" src=\"https://highload.today/wp-content/uploads/2021/08/image8-3.png\" alt=\"Структура Collection Framework в Java\" />"
    },
    {
        "area": "Java. Колекції",
        "title": "Яка різниця між ArrayList та LinkedList, та який коли краще використовувати",
        "answer": "ArrayList та LinkedList - це дві реалізації інтерфейсу List в Java, які використовують різні структури даних для зберігання елементів. ArrayList використовує масив, який може змінювати свій розмір, а LinkedList використовує подвійно зв’язаний список.Основні різниці між ArrayList та LinkedList можна підсумувати так:<ul><li><b>Доступ за індексом</b>: ArrayList дозволяє швидко отримати елемент за індексом, оскільки він просто повертає значення з масиву. LinkedList же потребує перебору елементів в списку, доки не дійде до потрібного індексу. Тому, якщо потребується частий доступ до елементів за індексом, краще використовувати ArrayList.</li><li><b>Додавання та видалення елементів</b>: LinkedList дозволяє швидко додавати та видаляти елементи з будь-якої позиції в списку, оскільки він просто змінює посилання між сусідніми елементами. ArrayList же потребує зсуву елементів масиву при додаванні або видаленні елемента не з кінця списку. Тому, якщо потребується часте додавання або видалення елементів з середини списку, краще використовувати LinkedList.</li><li><b>Використання пам’яті</b>: ArrayList використовує менше пам’яті, оскільки в ньому збергаються тільки значення елементiв. LinkedList же використовує бiльше пам’ятi, оскiльки в ньому зберiгаються значення елементiв та посилання на наступний та попереднiй елементи. Тому, якщо потребується економити пам’ять, краще використовувати ArrayList.</li></ul>"
    },
    {
        "area": "Java. Колекції",
        "title": "Яка різниця між HashSet та TreeSet",
        "answer": "HashSet та TreeSet - це дві реалізації інтерфейсу Set в Java, які використовують різні структури даних для зберігання елементів без дублікатів. HashSet використовує хеш-таблицю, а TreeSet використовує червоно-чорне дерево.Основні різниці між HashSet та TreeSet можна підсумувати так:<ul><li><b>Порядок елементів</b>:  HashSet зберігає елементи в випадковому порядку, тоді як TreeSet зберігає елементи в сортованому порядку за їхнім природним порядком або за компаратором, який можна передати при створенні TreeSet. Тому, якщо потребується зберегти порядок елементiв, краще використовувати TreeSet.</li><li><b>Null елементи</b>: HashSet дозволяє зберiгати null елемент, тодi як TreeSet не дозволяє цього. Якщо спробувати додати null елемент до TreeSet, буде кинуто NullPointerException. Тому, якщо потребується зберiгати null елемент, краще використовувати HashSet.</li><li><b>Швидкодiя</b>: HashSet швидший за TreeSet для бiльшостi операцiй, таких як додавання, пошук i видалення елементiв. HashSet має постiйну часову складнiсть O(1) для цих операцiй, тодi як TreeSet має логарифмiчну часову складнiсть O(log n) через сортування i балансування дерева. Тому, якщо потребується швидка обробка даних, краще використовувати HashSet.</li><li><b>Додатковi методи</b>: TreeSet має бiльше функцiональностей, нiж HashSet, оскiльки вiн реалiзує додатковi iнтерфейси SortedSet i NavigableSet. TreeSet надає методи для отримання першого i останнього елемента, найменшого елемента бiльшого або рiвного заданому, найбiльшого елемента меншого за заданий i т.д. Цi методи роблять TreeSet легшим у використаннi i потужнiшим за HashSet.</li></ul>"
    },
    {
        "area": "Java. Колекції",
        "title": "Що найчастіше використовують у якості ключа для Map",
        "answer": "В Map в Java можна використовувати будь-який об’єкт у якості ключа, але є деякі рекомендації та вимоги, які слід враховувати при виборі ключа:<ul><li>Ключ повинен бути <b>незмінним</b>. Якщо ключ зміниться після того, як був доданий до Map, то це може призвести до неправильної роботи Map, оскільки хеш-код і розташування ключа в Map також зміняться. Тому, краще використовувати незмінні класи, такі як String, Integer, Long тощо, або створювати власні незмінні класи для ключів.</li><li>Ключ повинен правильно реалізувати методи <b>equals()</b> та <b>hashCode()</b>. Це необхідно для того, щоб Map міг правильно порівнювати ключі за їх значенням і знаходити їх за їх хеш-кодом.</li><li>Ключ повинен бути <b>сумiсним</b> з типом Map. Рiзнi типи Map мають рiзнi вимоги до ключiв. Наприклад, HashMap дозволяє мати null ключi та значення, але TreeMap не дозволяє цього. Також TreeMap потребує, щоб ключi були Comparable або передавали Comparator при створеннi TreeMap.</li></ul>"
    },
    {
        "area": "Java Core. Enum",
        "title": "Що таке Enum",
        "answer": "<b>Enum</b> - це спеціальний тип класу в Java, який представляє групу констант (незмінних змінних, як <b>final змінні</b>). Для створення enum використовується ключове слово <b>enum</b> (замість class або interface), і константи розділяються комою. Enum можна використовувати для представлення групи значень, які не змінюються, наприклад, дні тижня, кольори, масть карт тощо.<p>Enum може мати атрибути і методи, як і звичайний клас. Єдина різниця в тому, що константи enum є public, static і final (незмiннi - не можуть бути перевизначенi). Enum не може бути використаний для створення об’єктiв i не може наслiдувати iншi класи (але може реалiзовувати iнтерфейси)."
    },
    {
        "area": "Java. Exceptions",
        "title": "Що таке Exceptions та як їх поділяють",
        "answer": "<b>Exceptions</b> - це об’єкти, які представляють помилки або непередбачувані ситуації, які виникають під час виконання програми. Exceptions порушують нормальний потік програми і можуть призвести до її зупинки, якщо не будуть обробленими.<p>Exceptions поділяються на два основних типи: checked і unchecked.<ul><li><b>Checked exceptions</b> - це exceptions, які повинні бути оброблені або оголошені у коді. Вони зазвичай пов’язані з помилками зовнішнього середовища, такими як втрата з’єднання з базою даних або неправильний формат файлу. Прикладами checked exceptions є IOException, SQLException, ClassNotFoundException тощо.</li><li><b>Unchecked exceptions</b> - це exceptions, які не потребують обробки або оголошення у коді. Вони зазвичай пов’язані з помилками програмування, такими як неправильний доступ до масиву або ділення на нуль. Прикладами unchecked exceptions є RuntimeException, NullPointerException, ArithmeticException тощо.</li></ul>"
    },
    {
        "area": "Java. Exceptions",
        "title": "Що таке обробка винятків",
        "answer": "Обробка exceptions - це механізм, який дозволяє виявити, перехопити і вирішити exceptions, щоб програма могла продовжити свою роботу або завершитися коректно. Обробка exceptions використовує ключові слова try, catch, finally і throw.<ul><li><b>try</b> - це блок коду, який може викликати exception і який потребує обробки.</li><li><b>catch</b> - це блок коду, який виконується, коли в try блоку виникає exception. В catch блоку можна визначити дії для вирішення exception або повідомлення про нього.</li><li><b>finally</b> - це блок коду, який виконується після try і catch блоків незалежно від того, чи був exception або ні. В finally блоку можна розмістити код для звільнення ресурсів або закриття з’єднань.</li><li><b>throw</b> - це оператор, який дозволяє створити і кинути свій власний exception. Це може бути корисно для позначення специфічних помилок у програмі.</li></ul>"
    },
    {
        "area": "Java. Exceptions",
        "title": "Що таке Try With Resources",
        "answer": "Try with resources - це спеціальна форма try блоку, яка дозволяє оголосити один або кілька ресурсів, які повинні бути закриті після виконання блоку. Ресурс - це об’єкт, який реалізує інтерфейс AutoCloseable або Closeable, наприклад, потоки вводу-виводу, з’єднання з базою даних тощо.<p>Try with resources забезпечує автоматичне закриття ресурсів незалежно від того, чи завершився try блок нормально або із помилкою. Це допомагає уникнути витоку ресурсів і зменшити кількість коду для обробки exceptions.<p>Для використання try with resources потрібно оголосити і ініціалізувати ресурси в дужках після ключового слова try. Ресурси можна розділяти крапкою з комою."
    },
    {
        "area": "Java. Патерни програмування",
        "title": "Що таке патерни програмування та які основні",
        "answer": "Патерни програмування - це напрацьовані ефективні підходи, техніки та правила вирішення задач при створенні програмного забезпечення.<p>Патерни програмування допомагають розробникам уникнути повторення коду, полегшити розуміння і підтримку програм, покращити архітектуру і дизайн програм, а також використовувати перевірені рішення для типових проблем.<p>Патерни програмування поділяються на три основні типи:<ul><li><b>Породжуючі (Creational)</b> - це патерни, які стосуються процесу створення об’єктів. Вони дозволяють абстрагуватися від конкретних класів і способів їх інстанціювання, а також контролювати кількість і життєвий цикл об’єктів. Прикладами породжуючих патернів є Singleton, Factory, Builder, Prototype тощо.</li><li><b>Структурні (Structural)</b> - це патерни, які стосуються складання об’єктів і класів у більш складні структури. Вони дозволяють адаптувати інтерфейси, зменшити залежності між компонентами, оптимізувати використання пам’яті і забезпечити гнучкість композиції об’єктів. Прикладами структурних патернiв є Adapter, Bridge, Composite, Decorator тощо.</li><li><b>Поведiнковi (Behavioural)</b> - це патерни, якi стосуються взаємодiї мiж об’єктами i класами. Вони дозволяють розподiлити обов’язки мiж об’єктами, координувати їх дiї, управляти потоком виконання i реалiзовувати складну логiку. Прикладами поведiнкових патернiв є Observer, Strategy, Command, Template Method тощо.</li></ul>"
    },
    {
        "area": "Java. Патерни програмування",
        "title": "Як в Java реалізувати Singleton патерн",
        "answer": "Singleton патерн - це патерн, який забезпечує, що клас може мати лише один об’єкт і надає глобальну точку доступу до цього об’єкта. Для реалізації Singleton патерну в Java, клас повинен виконувати наступні властивості12:<ul><li>Створити приватний конструктор класу, щоб обмежити створення об’єктів за межами класу.</li><li>Створити приватну статичну змінну, яка містить єдиний об’єкт класу.</li><li>Створити публічний статичний метод, який повертає об’єкт класу, це і є глобальна точка доступу для отримання об’єкта.</li></ul>"
    }
]